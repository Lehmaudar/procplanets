<!DOCTYPE html>
<html>
  <head>
    <title>ProcPlanets</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0,
      maximum-scale=1.0"
    />

    <!-- External libraries from the web -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.5/dat.gui.min.js"></script>
    <script src="http://wzrd.in/standalone/uuid%2Fv1@latest"></script>
    <script src="http://threejs.org/examples/js/controls/TrackballControls.js"></script> -->
    <!-- External libraries from local machine -->
    <script type="text/javascript" src="js/external/simplex-noise.js"></script>
    <script type="text/javascript" src="js/external/three.r96.js"></script>
    <script type="text/javascript" src="js/external/stats.min.js"></script>
    <script type="text/javascript" src="js/external/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/external/uuid_v1@latest.js"></script>
    <script
      type="text/javascript"
      src="js/external/TrackballControls.js"
    ></script>
    <script
      type="text/javascript"
      src="js/external/PointerLockControls.js"
    ></script>

    <script
      type="text/javascript"
      src="js/external/THREEx.KeyboardState.js"
    ></script>
    <script type="text/javascript" src="js/external/Tween.js"></script>

    <!-- Project js files -->
    <script type="text/javascript" src="js/icosphere.js"></script>

    <style>
      body {
        overflow: hidden;
        padding: 0;
        margin: 0;
        color: #222;
        background-color: #111;
        font-family: arial;
        font-size: 100%;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="text/javascript">
      var scene, renderer, composer, camera, icosphere;
      var stats, gui, cameraControls, keyboard;
      // var variables = datGui();
      var mouseSpeed = 0;
      let zoomSpeed;
      var clock = new THREE.Clock();
      var keyboard = new THREEx.KeyboardState();
      var simplex = new SimplexNoise(222);

      var trackballControls;
      var pointerLockControls;
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var pointer;
      var onGround = false;
      var skyPos = new THREE.Vector3();
      var target = new THREE.Vector3(3, -6, 6); // create on init
      var downTween, upTween;

      var frustum = new THREE.Frustum();
      var cameraVector = new THREE.Vector3();
      var colorsNeedUpdate = false;

      var t1, t0;

      init();
      var variables = datGui();
      animate();

      // dat.gui ui
      function datGui() {
        var Variables = function() {
          // this.spinSpeed = 0.0;
          this.tessConstant = 2;
          this.tessGive = 0.5;
          this.tessZoomIn = false;
          this.tessZoomOut = false;
          this.wireframe = false;
          this.addDetail = function() {
            t0 = performance.now();
            addDetail(faceCache);
            icosphere.geometry.elementsNeedUpdate = true;
            t1 = performance.now();
            console.log("AddDetail took " + (t1 - t0) + " milliseconds.");
          };
          this.addDetailOptimized = function() {
            t0 = performance.now();
            addDetail(findVisibleFaces(faceCache));
            icosphere.geometry.elementsNeedUpdate = true;
            t1 = performance.now();
            console.log("AddDetail took " + (t1 - t0) + " milliseconds.");
          };
          this.removeDetail = function() {
            t0 = performance.now();
            removeDetail();
            icosphere.geometry.elementsNeedUpdate = true;
            t1 = performance.now();
            console.log("RemoveDetail took " + (t1 - t0) + " milliseconds.");
          };
          this.vertexColors = true;
          this.useTreeStruc = false;
          this.smootherControls = true;
        };

        variables = new Variables();
        gui = new dat.GUI();

        var folder1 = gui.addFolder("Appearance");
        var folder2 = gui.addFolder("Tesselation");
        var folder3 = gui.addFolder("Controls");
        // folder1.open();
        folder2.open();
        // folder3.open();
        // folder1.add(variables, "spinSpeed", 0, 2);
        folder2.add(variables, "tessConstant", 0.01, 10);
        folder2.add(variables, "tessGive", 0, 10);
        folder2.add(variables, "tessZoomIn");
        folder2.add(variables, "tessZoomOut");
        folder2.add(variables, "useTreeStruc");
        folder2.add(variables, "addDetail");
        folder2.add(variables, "addDetailOptimized");
        folder2.add(variables, "removeDetail");
        var wireframe = folder1.add(variables, "wireframe");
        var vertexColors = folder1.add(variables, "vertexColors");
        wireframe.onChange(function(value) {
          icosphere.material.wireframe = value;
        });
        vertexColors.onChange(function(value) {
          value
            ? (icosphere.material.vertexColors = 1)
            : (icosphere.material.vertexColors = 0);
          icosphere.material.needsUpdate = true;
        });
        var smootherControls = folder3.add(variables, "smootherControls");
        // trackballControls.enabled = false;
        smootherControls.onChange(function(value) {
          value;
          if (value) {
            trackballControls.reset();
            trackballControls.minDistance = 0;
          } else {
            trackballControls.zoomSpeed = 1.2;
            trackballControls.rotateSpeed = 1.0;
            trackballControls.minDistance = 1.0001;
            trackballControls.reset();
          }
        });
        return variables;
      }

      // init the scene
      function init() {
        renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // window event listeners
        // window.addEventListener("wheel", onMouseWheel, false);
        window.addEventListener("resize", onWindowResize, false);

        // add keyboard
        keyboard = new THREEx.KeyboardState(renderer.domElement);
        renderer.domElement.setAttribute("tabIndex", "0");
        renderer.domElement.focus();

        // add Stats.js - https://github.com/mrdoob/stats.js
        stats = new Stats();
        stats.domElement.style.position = "absolute";
        stats.domElement.style.bottom = "0px";
        document.body.appendChild(stats.domElement);

        // create a scene
        scene = new THREE.Scene();

        // put a camera in the scene
        camera = new THREE.PerspectiveCamera(
          15,
          window.innerWidth / window.innerHeight,
          0.001,
          10000
        );
        camera.position.set(0, 0, 15);
        scene.add(camera);

        // create a camera contol
        trackballControls = new THREE.TrackballControls(
          camera,
          renderer.domElement
        );
        // trackballControls.minDistance = 1.00001;
        trackballControls.maxDistance = 40;

        // Objects
        icosphere();
        group = new THREE.Object3D();
        group.add(icosphere);
        scene.add(group);

        // Raycaster
        raycaster = new THREE.Raycaster();
        window.addEventListener("mousemove", onMouseMove, false);
        pointer = new THREE.Mesh(
          new THREE.SphereGeometry(0.03, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        pointer.material.color.setRGB(0.9, 0.9, 0.9);
        mover = new THREE.Mesh(
          new THREE.SphereGeometry(0.03, 8, 8),
          new THREE.MeshBasicMaterial({
            color: 0x0000ff
          })
        );
        scene.add(pointer);
        scene.add(mover);

        var downTween = new TWEEN.Tween(camera.position)
          .to(new THREE.Vector3().copy(pointer.position), 3000)
          .easing(TWEEN.Easing.Quadratic.InOut)
          .onComplete(() => {});

        document.body.onkeyup = e => {
          if (e.keyCode == 70) {
            updateFrustum();
            updateCullingVectors();
            findVisibleFaces(faceCache).forEach(face => {
              markFace(face, [0, 0, 1]);
            });
            // icosphere.geometry.elementsNeedUpdate = true;
            geom.colorsNeedUpdate = true;
          }

          if (e.keyCode == 83) {
            t0 = performance.now();
            for (let i = 0; i < 500; i++) {
              findVisibleFaces(faceCache);
            }
            t1 = performance.now();
            console.log(
              "FindVisibleFaces took " + (t1 - t0) + " milliseconds."
            );

            // upDateColors();
          }

          // subdivCacheFace(faceCache[1]);

          if (e.keyCode == 32) {
            if (onGround) {
              onGround = false;
              pointer.material.color.setRGB(0.9, 0.9, 0.9);
              if (downTween != undefined) downTween.stop();
              upTween = new TWEEN.Tween(camera.position)
                .to(new THREE.Vector3().copy(skyPos), 3000)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onComplete(() => {
                  trackballControls.enabled = true;
                });
              upTween.start();
            } else if (
              pointer.position.x != 0 &&
              pointer.position.y != 0 &&
              pointer.position.x != 0
            ) {
              onGround = true;
              if (upTween == undefined || !upTween._isPlaying) {
                skyPos.copy(camera.position);
              }
              if (upTween != undefined) upTween.stop();
              trackballControls.enabled = false;
              pointer.material.color.setRGB(0.7, 0.9, 0.7);
              downTween = new TWEEN.Tween(camera.position)
                .to(new THREE.Vector3().copy(pointer.position), 3000)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onComplete(() => {
                  t1 = performance.now();
                  console.log(
                    "Going on ground " + (t1 - t0) + " milliseconds."
                  );
                });
              t0 = performance.now();
              downTween.start();
            }
          }
        };
      }

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      // animation loop
      function animate() {
        requestAnimationFrame(animate);
        delta = clock.getDelta();

        // update camera controls
        if (trackballControls.enabled) {
          smootherControls(delta);
        }

        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObject(icosphere);
        if (intersects.length == 0) {
          pointer.position.set(0, 0, 0);
        } else {
          for (var i = 0; i < intersects.length; i++) {
            // const index = intersects[i].faceIndex;
            // const cacheFace = faceCache.filter(
            //   face => face.geometryIndex == index
            // )[0];
            // pointer.position.set(...multiplyPos(cacheFace.middlePos, 1.05));
            const point = intersects[i].point;
            pointer.position.set(...multiplyPos(vec3ToArray(point), 1.05));
          }
        }

        TWEEN.update();

        // focus on canvas in case gui has been pressed
        renderer.domElement.setAttribute("tabIndex", "0");
        renderer.domElement.focus();

        render();

        stats.update();
      }

      function render() {
        // variable which is increase by Math.PI every seconds - usefull for animation
        var PIseconds = Date.now() * Math.PI;

        if (variables.useTreeStruc) {
          LOD(
            camera.position,
            variables.tessConstant / 100,
            variables.tessGive / 30,
            variables.tessZoomIn,
            variables.tessZoomOut
          );
        } else {
          LODold(
            camera.position,
            variables.tessConstant / 100,
            variables.tessGive / 30,
            variables.tessZoomIn,
            variables.tessZoomOut
          );
        }
        if (colorsNeedUpdate) upDateColors();

        renderer.render(scene, camera);
      }

      function smootherControls() {
        const oldCameraPos = vec3ToArray(camera.position);
        const oldCameraRot = vec3ToArray(camera.rotation);
        const oldCameraDist = distance(oldCameraPos, [0, 0, 0]);

        const oldTargetPos = vec3ToArray(trackballControls.target);
        const oldTargetDist = distance(oldTargetPos, [0, 0, 0]);

        // dist, startvalue, startvalue + endvalue, endDist
        ease = easeFunc(oldCameraDist - 1, 0, 1, 40);

        trackballControls.zoomSpeed = ease;
        trackballControls.rotateSpeed = ease * 2;
        trackballControls.panSpeed = ease / 5;

        trackballControls.update();

        const newCameraDist = distance(vec3ToArray(camera.position), [0, 0, 0]);
        if (newCameraDist < 1.00002) {
          camera.position.set(...oldCameraPos);
          camera.rotation.set(...oldCameraRot);
        }

        const newTargetDist = distance(vec3ToArray(trackballControls.target), [
          0,
          0,
          0
        ]);
        if (newTargetDist > 1.00002) {
          trackballControls.target.normalize();
        }
      }

      function easeFunc(t, b, c, d) {
        var ts = (t /= d) * t;
        var tc = ts * t;
        return b + c * (-1 * ts * ts + 4 * tc + -6 * ts + 4 * t);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>
  </body>
</html>
