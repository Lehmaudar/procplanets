<!DOCTYPE html>
<html>
  <head>
    <title>ProcPlanets</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0,
      maximum-scale=1.0"
    />

    <!-- External libraries from local machine (add http://procplanets.tintdisain.ee before each source) -->
    <script type="text/javascript" src="js/external/simplex-noise.js"></script>
    <script type="text/javascript" src="js/external/three.r96.js"></script>
    <script type="text/javascript" src="js/external/stats.min.js"></script>
    <script type="text/javascript" src="js/external/dat.gui.min.js"></script>
    <script
      type="text/javascript"
      src="js/external/TrackballControls.js"
    ></script>
    <script
      type="text/javascript"
      src="js/external/PointerLockControls.js"
    ></script>
    <script
      type="text/javascript"
      src="js/external/THREEx.KeyboardState.js"
    ></script>
    <script type="text/javascript" src="js/external/Tween.js"></script>

    <!-- Project js files -->
    <script type="text/javascript" src="js/icosphere.js"></script>
    <script type="text/javascript" src="js/controls.js"></script>

    <style>
      body {
        overflow: hidden;
        padding: 0;
        margin: 0;
        color: #222;
        background-color: #111;
        font-family: arial;
        font-size: 100%;
      }

      #generate {
        position: fixed;
        font-size: 12px;
        height: 14px;
        width: 200px;
        top: 100px;
        left: 100px;
        color: white;
        /* background-color: brown; */
        visibility: hidden;
      }
    </style>
  </head>
  <body>
    <div id="generate">press to see changes â†’</div>
    <script type="text/javascript">
      var scene, renderer, composer, camera, icosphere, axes;
      var stats, gui, cameraControls, keyboard;
      var variables = datGui();
      var mouseSpeed = 0;
      var zoomSpeed;
      var clock = new THREE.Clock();
      var keyboard = new THREEx.KeyboardState();
      var simplex = new SimplexNoise(variables.seed);

      var trackballControls, pointerLockControls, pointer;
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var onGround = false;

      var skyPos = new THREE.Vector3();
      var skyRot = new THREE.Euler();
      var testVec = new THREE.Vector3(0, 0, 0);
      var target = new THREE.Vector3(3, -6, 6); // create on init
      var downTween, upTween;

      var frustum = new THREE.Frustum();
      var cameraVector = new THREE.Vector3();
      var colorsNeedUpdate = false;

      var t1, t0;
      var folder1, folder2, folder3;
      var colorNames = [];
      var noiseNames = [];
      var presets = {};

      var conPointer, camPointerHelper, conOrbit;
      var generateRect = {
        top: 0,
        left: 0
      };

      // createjs.RotationPlugin.install();

      init();
      animate();

      // dat.gui ui
      function datGui() {
        var Variables = function() {
          this.wireframe = false;
          this.axes = false;
          this.vertexColors = true;

          this.tessConstant = 12;
          this.tessGive = 0;
          this.tessZoomIn = false;
          this.tessZoomOut = false;
          this.addDetail = () => {
            t0 = performance.now();
            addDetail(faceCache);
            icosphere.geometry.elementsNeedUpdate = true;
            t1 = performance.now();
            console.log("AddDetail took " + (t1 - t0) + " milliseconds.");
          };
          this.addDetailOptimized = () => {
            t0 = performance.now();
            addDetail(findVisibleFaces(faceCache));
            icosphere.geometry.elementsNeedUpdate = true;
            t1 = performance.now();
            console.log("AddDetail took " + (t1 - t0) + " milliseconds.");
          };
          this.removeDetail = () => {
            t0 = performance.now();
            removeDetail();
            icosphere.geometry.elementsNeedUpdate = true;
            t1 = performance.now();
            console.log("RemoveDetail took " + (t1 - t0) + " milliseconds.");
          };

          this.addNewColor = function() {
            addNewColor([212, 10, 10], Math.random());
            refreshIcosphere();
          };

          this.seed = 41;
          this.addNewNoise = function() {
            addNewNoise(Math.random(), 1);
          };
          this.maxLevel = 0.2;
          this.minLevel = 0;
          this.generate = () => {
            refreshIcosphere();
            generateInfo(false);
          };

          this.randomize = () => {
            setRandom();
          };

          this.Earth = () => {
            setPreset(...presets.earth);
          };
          this.Sun = () => {
            setPreset(...presets.sun);
          };
          this.Mars = () => {
            if (colorNames.length < 4) {
              addNewColor([0, 0, 0], 0);
            }
            setPreset(...presets.mars);
          };
        };

        variables = new Variables();
        gui = new dat.GUI();

        gui.add(variables, "randomize");
        folder1 = gui.addFolder("Appearance");
        folder2 = gui.addFolder("Tesselation");
        folder3 = gui.addFolder("Colors");
        folder4 = gui.addFolder("Terrain");
        folder5 = folder4.addFolder("Noise");
        folder6 = folder4.addFolder("Height");
        folder7 = gui.addFolder("Presets");
        // folder2.open();
        folder3.open();
        folder4.open();
        folder5.open();
        folder6.open();

        folder2.add(variables, "tessConstant", 0.01, 20);
        // folder2.add(variables, "tessGive", 0, 10);
        folder2.add(variables, "tessZoomIn");
        // folder2.add(variables, "tessZoomOut");
        // folder2.add(variables, "useTreeStruc");
        folder2.add(variables, "addDetail");
        folder2.add(variables, "addDetailOptimized");
        folder2.add(variables, "removeDetail");
        folder1.add(variables, "wireframe").onChange(value => {
          icosphere.material.wireframe = value;
        });
        folder1.add(variables, "axes").onChange(value => {
          value ? (axes.visible = true) : (axes.visible = false);
        });
        folder1.add(variables, "vertexColors").onChange(value => {
          value
            ? (icosphere.material.vertexColors = 1)
            : (icosphere.material.vertexColors = 0);
          icosphere.material.needsUpdate = true;
        });

        folder3.add(variables, "addNewColor");

        folder5.add(variables, "seed", 0, 50).onChange(value => {
          simplex = new SimplexNoise(value);
          generateInfo(true);
        });
        folder5.add(variables, "addNewNoise");
        folder6
          .add(variables, "maxLevel", 0.01, 1)
          .step(0.01)
          .onChange(value => {
            if (value < Math.abs(variables.minLevel))
              variables.minLevel = -variables.maxLevel;
            generateInfo(true);
          });

        folder6
          .add(variables, "minLevel", -1, 0)
          .step(0.01)
          .onChange(value => {
            if (Math.abs(value) > variables.maxLevel)
              variables.minLevel = -variables.maxLevel;
            generateInfo(true);
          })
          .listen();
        folder4.add(variables, "generate");

        folder7.add(variables, "Sun");
        folder7.add(variables, "Earth");
        folder7.add(variables, "Mars");

        return variables;
      }

      // init the scene
      function init() {
        renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // window event listeners
        // window.addEventListener("wheel", onMouseWheel, false);
        window.addEventListener("resize", onWindowResize, false);

        // add keyboard
        keyboard = new THREEx.KeyboardState(renderer.domElement);
        renderer.domElement.setAttribute("tabIndex", "0");
        renderer.domElement.focus();

        // add Stats.js - https://github.com/mrdoob/stats.js
        stats = new Stats();
        stats.domElement.style.position = "absolute";
        stats.domElement.style.bottom = "0px";
        document.body.appendChild(stats.domElement);

        // create a scene
        scene = new THREE.Scene();

        // put a camera in the scene
        orgCamera = new THREE.PerspectiveCamera(
          15,
          window.innerWidth / window.innerHeight,
          0.001,
          10000
        );
        orgCamera.position.set(0, 0, 15);
        scene.add(orgCamera);
        // camera = orgCamera;

        // Dat.GUI
        addNewColor([0, 0, 0], 0.0);
        addNewColor([0, 0, 0], 0.0);
        addNewColor([0, 0, 0], 0.0);
        addNewNoise(0, 0);
        addNewNoise(0, 0);
        addNewNoise(0, 0);
        generateInfo(false);

        // Objects
        icosphere = initIcosphere();
        group = new THREE.Object3D();
        group.add(icosphere);
        scene.add(group);
        axes = new THREE.AxesHelper(2);
        axes.visible = false;
        icosphere.add(axes);

        // Raycaster
        raycaster = new THREE.Raycaster();
        window.addEventListener("mousemove", onMouseMove, false);
        pointer = new THREE.Mesh(
          new THREE.SphereGeometry(0.03, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        pointer.material.color.setRGB(0.9, 0.9, 0.9);
        // pointer.add(new THREE.AxesHelper(0.1));
        pointer.visible = false;
        scene.add(pointer);

        initControls();
        setPreset(...presets.earth);
      }

      // animation loop
      function animate() {
        requestAnimationFrame(animate);
        delta = clock.getDelta();

        // update camera controls
        if (conOrbit != undefined && conOrbit.enabled) {
          smootherControls(delta);
          // conOrbit.update();
        }

        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObject(icosphere);
        if (intersects.length == 0) {
          pointer.position.set(0, 0, 0);
        } else {
          for (var i = 0; i < intersects.length; i++) {
            const point = intersects[i].point;
            pointer.position.set(...multiplyPos(vec3ToArray(point), 1.005));
          }
        }

        TWEEN.update();

        // focus on canvas in case gui has been pressed
        renderer.domElement.setAttribute("tabIndex", "0");
        renderer.domElement.focus();

        render();

        stats.update();
      }

      function render() {
        // variable which is increase by Math.PI every seconds - usefull for animation
        var PIseconds = Date.now() * Math.PI;

        LOD(
          camera.position,
          variables.tessConstant / 100,
          variables.tessGive / 30,
          variables.tessZoomIn,
          variables.tessZoomOut
        );

        if (colorsNeedUpdate) upDateColors();

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
